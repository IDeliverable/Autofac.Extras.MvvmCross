using System;
using Cirrious.CrossCore.Core;
using Cirrious.CrossCore.IoC;
using System.Linq;
using System.Globalization;
using Autofac.Core.Registration;
using Autofac.Core;

namespace Autofac.Extras.MvvmCross
{
    /// <summary>
    /// Wrapper around <see cref="Autofac"/> and <see cref="MvvmCross"/>
    /// </summary>
    public class AutofacMvxIocProvider : MvxSingleton<IMvxIoCProvider>, IMvxIoCProvider {
        private static readonly string TypeNotRegisteredAsSingleton = "Type '{0}' not registered as singleton.";

        private readonly IContainer _container;

        public AutofacMvxIocProvider(IContainer container) {
            if (container == null) throw new ArgumentNullException("container");
            _container = container;
        }

        /// <summary>
        /// Ask <see cref="Autofac"/> whether it can resolve a type.
        /// </summary>
        public bool CanResolve<T>() where T : class {
            return CanResolve(typeof(T));
        }

        /// <summary>
        /// Ask <see cref="Autofac"/> whether it can resolve a type.
        /// </summary>
        public bool CanResolve(Type type) {
            return _container.IsRegistered(type);
        }

        /// <summary>
        /// Resolve an instance of T.
        /// </summary>
        /// <returns>Instance of T generated by <see cref="Autofac"/></returns>
        public T Resolve<T>() where T : class {
            return (T)Resolve(typeof(T));
        }

        /// <summary>
        /// Resolve an instance of the Type provided.
        /// </summary>
        /// <returns>Object generated by <see cref="Autofac"/></returns>
        public object Resolve(Type type) {
            return _container.Resolve(type);
        }

        /// <summary>
        /// Resolve an instance of T.
        /// </summary>
        /// <returns>Instance of T generated by <see cref="Autofac"/></returns>
        public T Create<T>() where T : class {
            return (T)Create(typeof(T));
        }

        /// <summary>
        /// Resolve an instance of the Type provided.
        /// </summary>
        /// <returns>Object generated by <see cref="Autofac"/></returns>
        public object Create(Type type) {
            return Resolve(type);
        }

        /// <summary>
        /// Resolves a singleton instance of T.
        /// </summary>
        /// <returns>Singleton instance of T generated by <see cref="Autofac"/></returns>
        public T GetSingleton<T>() where T : class {
            return (T)GetSingleton(typeof(T));
        }

        /// <summary>
        /// Resolves a singleton instance of the Type provided.
        /// </summary>
        /// <returns>Singleton instance of T generated by <see cref="Autofac"/></returns>
        public object GetSingleton(Type type) {
            if (!ReferenceEquals(Resolve(type), Resolve(type)))
            {
                throw new DependencyResolutionException(String.Format(CultureInfo.CurrentCulture, TypeNotRegisteredAsSingleton, type));
            }
            return Resolve(type);
        }

        /// <summary>
        /// Attempts to resolve an instance of T.
        /// </summary>
        public bool TryResolve<T>(out T resolved) where T : class {
            return _container.TryResolve<T>(out resolved);
        }

        /// <summary>
        /// Attempts to resolve an instance of the Type provided.
        /// </summary>
        public bool TryResolve(Type type, out object resolved) {
            return _container.TryResolve(type, out resolved);
        }

        /// <summary>
        /// Registers TTo to be returned when <see cref="Autofac"/> resolves TFrom.
        /// </summary>
        public void RegisterType<TFrom, TTo>()
            where TFrom : class
            where TTo : class, TFrom {
            RegisterType(typeof(TFrom), typeof(TTo));
        }

        /// <summary>
        /// Registers the `to` Type to be returned when <see cref="Autofac"/> resolves the `from` Type.
        /// </summary>
        public void RegisterType(Type from, Type to) {
            var cb = new ContainerBuilder();
            cb.RegisterType(to).As(from).AsSelf();
            cb.Update(_container);
        }

        /// <summary>
        /// Registers `instance` to be returned when <see cref="Autofac"/> resolves TInterface.
        /// </summary>
        public void RegisterSingleton<TInterface>(TInterface instance) where TInterface : class {
            RegisterSingleton(typeof(TInterface), instance);
        }

        /// <summary>
        /// Registers `instance` to be returned when <see cref="Autofac"/> resolves the `type` Type.
        /// </summary>
        public void RegisterSingleton(Type type, object instance) {
            var cb = new ContainerBuilder();
            cb.RegisterInstance(instance).As(type).AsSelf().SingleInstance();
            cb.Update(_container);
        }

        /// <summary>
        /// Registers `constructor` Func to be called when <see cref="Autofac"/> resolves TInterface.
        /// </summary>
        public void RegisterSingleton<TInterface>(Func<TInterface> constructor) where TInterface : class {
            RegisterSingleton(typeof(TInterface), constructor);
        }

        /// <summary>
        /// Registers `constructor` Func to be called when <see cref="Autofac"/> resolves the `type` Type.
        /// </summary>
        public void RegisterSingleton(Type tInterface, Func<object> constructor) {
            var cb = new ContainerBuilder();
            cb.Register(cc => constructor()).As(tInterface).AsSelf().SingleInstance();
            cb.Update(_container);
        }

        /// <summary>
        /// Resolve an instance of T.
        /// </summary>
        /// <returns>Instance of T generated by <see cref="Autofac"/></returns>
        public T IoCConstruct<T>() where T : class {
            return (T)IoCConstruct(typeof(T));
        }

        /// <summary>
        /// Resolve an instance of the Type provided.
        /// </summary>
        /// <returns>Object generated by <see cref="Autofac"/></returns>
        public object IoCConstruct(Type type) {
            return Resolve(type);
        }

        /// <summary>
        /// Registers `action` to be called when <see cref="Autofac"/> registers T.
        /// </summary>
        public void CallbackWhenRegistered<T>(Action action) {
            CallbackWhenRegistered(typeof(T), action);
        }

        /// <summary>
        /// Registers `action` to be called when <see cref="Autofac"/> registers the `type` Type.
        /// </summary>
        public void CallbackWhenRegistered(Type type, Action action) {
            _container.ComponentRegistry.Registered += (sender, args) => {
                if (args.ComponentRegistration.Services.OfType<TypedService>().Any(x => x.ServiceType == type)) {
                    action();
                }
            };
        }
    }
}

